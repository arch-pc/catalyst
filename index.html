<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RS3 Task Manager</title>
    <style>
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-selected: #d4edda;
            --border-color: #dee2e6;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --hover-bg: #e9ecef;
            --focus-outline: #0066cc;
            --warning-bg: #fff3cd;
            --warning-text: #856404;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --border-radius: 4px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: var(--spacing-md);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: var(--spacing-lg);
            max-width: 1400px;
            margin: 0 auto;
            min-height: calc(100vh - 2rem);
        }

        .main-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
        }

        .sidebar {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            height: fit-content;
            position: sticky;
            top: var(--spacing-md);
        }

        .category-tabs {
            display: flex;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--spacing-sm);
        }

        .category-tab {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .category-tab:hover {
            background: var(--hover-bg);
        }

        .category-tab.active {
            background: var(--focus-outline);
            color: white;
            border-color: var(--focus-outline);
        }

        .category-tab.all {
            font-weight: 600;
        }

        .loading {
            text-align: center;
            color: var(--text-secondary);
            padding: var(--spacing-lg);
        }

        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item, .note-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-sm);
            padding: var(--spacing-md);
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            will-change: transform, opacity;
        }

        .task-item:hover, .note-item:hover {
            background: var(--hover-bg);
        }

        .task-item:focus, .note-item:focus {
            outline: 2px solid var(--focus-outline);
            outline-offset: 2px;
        }

        .task-item.selected {
            background: var(--bg-selected);
            border-color: #28a745;
        }

        .task-item.minimized .task-details,
        .task-item.minimized .task-requirements {
            display: none;
        }

        .task-item.collapsed {
            display: none;
        }

        .task-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .task-icon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
            background: var(--hover-bg);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .task-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--border-radius);
        }

        .task-title {
            flex: 1;
            font-weight: 500;
        }

        .task-controls {
            display: flex;
            gap: var(--spacing-xs);
            margin-left: auto;
        }

        .btn {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-xs) var(--spacing-sm);
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: var(--hover-bg);
        }

        .btn:focus {
            outline: 2px solid var(--focus-outline);
            outline-offset: 2px;
        }

        .task-details {
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .task-requirements {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .requirement-img {
            width: 20px;
            height: 20px;
            object-fit: cover;
            border-radius: var(--border-radius);
        }

        .task-meta {
            position: absolute;
            bottom: var(--spacing-sm);
            right: var(--spacing-sm);
            display: flex;
            gap: var(--spacing-xs);
            align-items: center;
        }

        .task-category {
            background: var(--hover-bg);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius);
            font-size: 0.625rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .task-points {
            background: var(--focus-outline);
            color: white;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius);
            font-size: 0.75rem;
            font-weight: 600;
        }

        .sidebar-section {
            margin-bottom: var(--spacing-lg);
        }

        .sidebar-section:last-child {
            margin-bottom: 0;
        }

        .sidebar-title {
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .points-counter {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            text-align: center;
            padding: var(--spacing-md);
            background: var(--hover-bg);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-md);
        }

        .category-controls {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .category-btn {
            width: 100%;
            text-align: left;
            justify-content: space-between;
            display: flex;
            align-items: center;
        }

        .note-input-group {
            display: flex;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
        }

        .note-input {
            flex: 1;
            padding: var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.875rem;
        }

        .note-input:focus {
            outline: 2px solid var(--focus-outline);
            outline-offset: 2px;
        }

        .notes-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .note-item {
            cursor: move;
            padding: var(--spacing-sm);
        }

        .note-item.in-main-list {
            background: #f0f8ff;
            border-color: #0066cc;
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .note-title {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .note-body {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
        }

        .note-edit {
            width: 100%;
            border: none;
            background: none;
            resize: vertical;
            min-height: 40px;
            font-family: inherit;
            font-size: 0.75rem;
        }

        .note-edit:focus {
            outline: 1px solid var(--focus-outline);
        }

        .data-status {
            font-size: 0.75rem;
            margin-bottom: var(--spacing-sm);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: var(--spacing-xs);
            margin-bottom: var(--spacing-xs);
            border-radius: var(--border-radius);
        }

        .status-success {
            background: #d1e7dd;
            color: #0f5132;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .status-warning {
            background: var(--warning-bg);
            color: var(--warning-text);
        }

        .drag-over {
            border-color: var(--focus-outline);
            background: var(--hover-bg);
        }

        .dragging {
            opacity: 0.8;
            transform: rotate(2deg);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .drag-placeholder {
            border: 2px dashed var(--focus-outline);
            background: rgba(0, 102, 204, 0.1);
            height: 60px;
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-sm);
        }

        .reset-btn {
            background: #dc3545;
            color: white;
            border: none;
            width: 100%;
            padding: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .reset-btn:hover {
            background: #c82333;
        }

        .performance-info {
            font-size: 0.625rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: var(--spacing-sm);
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }
            
            .sidebar {
                position: static;
                order: -1;
            }

            .category-tabs {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <main class="main-content">
            <div class="category-tabs">
                <button id="allTab" class="category-tab all active" data-category="all">
                    All (<span id="allCount">0</span>)
                </button>
            </div>
            <div id="loading" class="loading">Loading tasks...</div>
            <ul id="taskList" class="task-list" style="display: none;"></ul>
        </main>
        
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Total Points</div>
                <div id="pointsCounter" class="points-counter">0</div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Categories</div>
                <div id="categoryControls" class="category-controls"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Add Note</div>
                <div class="note-input-group">
                    <input type="text" id="noteInput" class="note-input" placeholder="Note title...">
                    <button id="addNoteBtn" class="btn">Add</button>
                </div>
                <div id="notesList" class="notes-list"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Data Status</div>
                <div id="dataStatus" class="data-status"></div>
            </div>
            
            <button id="resetBtn" class="btn reset-btn">Reset All Data</button>
            
            <div class="performance-info">
                <div>Visible tasks: <span id="visibleCount">0</span></div>
                <div>Total tasks: <span id="totalCount">0</span></div>
            </div>
        </aside>
    </div>

    <script>
        class TaskManager {
            constructor() {
                this.tasks = [];
                this.notes = [];
                this.state = {
                    selectedTasks: new Set(),
                    minimizedTasks: new Set(),
                    collapsedCategories: new Set(),
                    itemOrder: [],
                    totalPoints: 0,
                    activeCategory: 'all'
                };
                this.categories = ['easy', 'medium', 'hard', 'elite', 'master'];
                this.dataStatus = {};
                this.noteIdCounter = 0;
                this.dragPlaceholder = null;
                this.renderTimeouts = new Set();
                this.dragState = null;
                
                this.init();
            }
            
            async init() {
                this.loadState();
                await this.loadTasks();
                this.setupEventListeners();
                this.render();
                
                // Expose API
                window.app = {
                    exportState: () => this.exportState(),
                    importState: (json) => this.importState(json)
                };
            }
            
            // Try combined file first, then individual files
            async loadTasks() {
                try {
                    // Try combined file first
                    const response = await fetch('all-tasks.json');
                    if (response.ok) {
                        const data = await response.json();
                        this.loadFromCombinedFile(data);
                    } else {
                        // Fallback to individual files
                        await this.loadFromIndividualFiles();
                    }
                } catch (error) {
                    console.warn('Failed to load combined file, trying individual files');
                    await this.loadFromIndividualFiles();
                }
                
                this.optimizeTaskOrder();
                this.updateDataStatus();
                this.setupCategoryTabs();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('taskList').style.display = 'block';
            }

            loadFromCombinedFile(data) {
                this.tasks = [];
                let globalIndex = 0;
                
                this.categories.forEach(category => {
                    if (data[category] && Array.isArray(data[category])) {
                        const categoryTasks = data[category].map((item, index) => ({
                            id: `${category}::${index}`,
                            category,
                            originalIndex: index,
                            globalIndex: globalIndex++,
                            area: item.Area || '',
                            task: item.Task || 'Untitled Task',
                            information: item.Information || '',
                            requirements: {
                                text: item.Requirements?.text || '',
                                img: item.Requirements?.img || ''
                            },
                            points: this.parsePoints(item.Pts)
                        }));
                        
                        this.tasks.push(...categoryTasks);
                        this.dataStatus[category] = { status: 'success', count: categoryTasks.length };
                    } else {
                        this.dataStatus[category] = { status: 'error', error: 'Category not found in combined file' };
                    }
                });
                
                // Initialize order if first load
                if (this.state.itemOrder.length === 0) {
                    this.state.itemOrder = this.tasks.map(task => ({ type: 'task', id: task.id }));
                }
            }
            
            async loadFromIndividualFiles() {
                const loadPromises = this.categories.map(async (category, categoryIndex) => {
                    try {
                        const response = await fetch(`${category}.json`);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const data = await response.json();
                        
                        if (!Array.isArray(data)) throw new Error('Invalid JSON format');
                        
                        const tasks = data.map((item, index) => ({
                            id: `${category}::${index}`,
                            category,
                            originalIndex: index,
                            globalIndex: categoryIndex * 1000 + index,
                            area: item.Area || '',
                            task: item.Task || 'Untitled Task',
                            information: item.Information || '',
                            requirements: {
                                text: item.Requirements?.text || '',
                                img: item.Requirements?.img || ''
                            },
                            points: this.parsePoints(item.Pts)
                        }));
                        
                        this.dataStatus[category] = { status: 'success', count: tasks.length };
                        return tasks;
                    } catch (error) {
                        this.dataStatus[category] = { status: 'error', error: error.message };
                        return [];
                    }
                });
                
                const taskArrays = await Promise.all(loadPromises);
                this.tasks = taskArrays.flat();
                
                // Initialize order if first load
                if (this.state.itemOrder.length === 0) {
                    this.state.itemOrder = this.tasks.map(task => ({ type: 'task', id: task.id }));
                }
            }

            optimizeTaskOrder() {
                // Sort tasks by globalIndex for consistent order
                this.tasks.sort((a, b) => a.globalIndex - b.globalIndex);
                
                // Update itemOrder with new tasks
                const existingIds = new Set(this.state.itemOrder.map(item => item.id));
                const newTasks = this.tasks.filter(task => !existingIds.has(task.id));
                
                newTasks.forEach(task => {
                    this.state.itemOrder.push({ type: 'task', id: task.id });
                });
            }
            
            parsePoints(pts) {
                if (typeof pts === 'number') return pts;
                if (typeof pts === 'string') {
                    const parsed = parseInt(pts, 10);
                    return isNaN(parsed) ? 0 : parsed;
                }
                return 0;
            }
            
            loadState() {
                try {
                    const saved = localStorage.getItem('rs3TasksState:v2');
                    if (saved) {
                        const state = JSON.parse(saved);
                        this.state = { ...this.state, ...state };
                        this.state.selectedTasks = new Set(state.selectedTasks || []);
                        this.state.minimizedTasks = new Set(state.minimizedTasks || []);
                        this.state.collapsedCategories = new Set(state.collapsedCategories || []);
                        this.notes = state.notes || [];
                        this.noteIdCounter = Math.max(0, ...this.notes.map(n => parseInt(n.id.split('::')[1]) || 0)) + 1;
                    }
                } catch (error) {
                    console.warn('Failed to load state:', error);
                }
            }
            
            saveState() {
                // Debounce saving for better performance
                if (this.saveTimeout) clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => {
                    try {
                        const state = {
                            ...this.state,
                            selectedTasks: Array.from(this.state.selectedTasks),
                            minimizedTasks: Array.from(this.state.minimizedTasks),
                            collapsedCategories: Array.from(this.state.collapsedCategories),
                            notes: this.notes
                        };
                        localStorage.setItem('rs3TasksState:v2', JSON.stringify(state));
                    } catch (error) {
                        console.warn('Failed to save state:', error);
                    }
                }, 100);
            }

            setupCategoryTabs() {
                const tabsContainer = document.querySelector('.category-tabs');
                const allTab = document.getElementById('allTab');
                const allCount = document.getElementById('allCount');
                
                // Update all count
                allCount.textContent = this.tasks.length;
                
                // Add category tabs
                this.categories.forEach(category => {
                    const count = this.tasks.filter(t => t.category === category).length;
                    if (count === 0) return;
                    
                    const tab = document.createElement('button');
                    tab.className = 'category-tab';
                    tab.dataset.category = category;
                    tab.innerHTML = `${category} (${count})`;
                    
                    tab.addEventListener('click', () => {
                        this.setActiveCategory(category);
                    });
                    
                    tabsContainer.appendChild(tab);
                });

                // All tab event listener
                allTab.addEventListener('click', () => {
                    this.setActiveCategory('all');
                });
            }

            setActiveCategory(category) {
                this.state.activeCategory = category;
                
                // Update active tab
                document.querySelectorAll('.category-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.category === category || 
                        (category === 'all' && tab.id === 'allTab'));
                });
                
                this.saveState();
                this.renderTasks();
            }
            
            setupEventListeners() {
                // Add note
                document.getElementById('addNoteBtn').addEventListener('click', () => this.addNote());
                document.getElementById('noteInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.addNote();
                });
                
                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    if (confirm('Reset all data? This cannot be undone.')) {
                        localStorage.removeItem('rs3TasksState:v2');
                        localStorage.removeItem('rs3TasksState:v1');
                        location.reload();
                    }
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
            }
            
            addNote() {
                const input = document.getElementById('noteInput');
                const title = input.value.trim();
                if (!title) return;
                
                const note = {
                    id: `note::${this.noteIdCounter++}`,
                    title,
                    body: '',
                    location: 'sidebar',
                    editing: false
                };
                
                this.notes.push(note);
                input.value = '';
                this.saveState();
                this.renderNotes();
            }
            
            deleteNote(noteId) {
                this.notes = this.notes.filter(n => n.id !== noteId);
                this.state.itemOrder = this.state.itemOrder.filter(item => 
                    item.type !== 'note' || item.id !== noteId
                );
                this.saveState();
                this.render();
            }
            
            toggleNoteEdit(noteId) {
                const note = this.notes.find(n => n.id === noteId);
                if (note) {
                    note.editing = !note.editing;
                    this.renderNotes();
                }
            }
            
            updateNoteBody(noteId, body) {
                const note = this.notes.find(n => n.id === noteId);
                if (note) {
                    note.body = body;
                    this.saveState();
                }
            }
            
            toggleTaskSelection(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                if (this.state.selectedTasks.has(taskId)) {
                    this.state.selectedTasks.delete(taskId);
                    this.state.totalPoints -= task.points;
                } else {
                    this.state.selectedTasks.add(taskId);
                    this.state.totalPoints += task.points;
                }
                
                this.saveState();
                this.updatePointsDisplay();
                
                // Update only the specific task element
                const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskElement) {
                    taskElement.classList.toggle('selected', this.state.selectedTasks.has(taskId));
                    taskElement.setAttribute('aria-pressed', this.state.selectedTasks.has(taskId));
                }
            }
            
            toggleTaskMinimized(taskId) {
                if (this.state.minimizedTasks.has(taskId)) {
                    this.state.minimizedTasks.delete(taskId);
                } else {
                    this.state.minimizedTasks.add(taskId);
                }
                
                this.saveState();
                
                // Update only the specific task element
                const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskElement) {
                    taskElement.classList.toggle('minimized', this.state.minimizedTasks.has(taskId));
                    const btn = taskElement.querySelector('.minimize-btn');
                    if (btn) {
                        btn.textContent = this.state.minimizedTasks.has(taskId) ? 'Expand' : 'Minimize';
                    }
                }
            }
            
            toggleCategoryCollapsed(category) {
                if (this.state.collapsedCategories.has(category)) {
                    this.state.collapsedCategories.delete(category);
                } else {
                    this.state.collapsedCategories.add(category);
                }
                
                this.saveState();
                this.renderTasks();
                this.renderCategoryControls();
            }
            
            updatePointsDisplay() {
                document.getElementById('pointsCounter').textContent = this.state.totalPoints;
            }
            
            updateDataStatus() {
                const statusEl = document.getElementById('dataStatus');
                statusEl.innerHTML = '';
                
                Object.entries(this.dataStatus).forEach(([category, status]) => {
                    const item = document.createElement('div');
                    item.className = 'status-item';
                    
                    if (status.status === 'success') {
                        item.className += ' status-success';
                        item.innerHTML = `<span>${category}</span><span>${status.count} tasks</span>`;
                    } else {
                        item.className += ' status-error';
                        item.innerHTML = `<span>${category}</span><span>Error</span>`;
                        item.title = status.error;
                    }
                    
                    statusEl.appendChild(item);
                });
                
                if (this.tasks.length === 0) {
                    const guidance = document.createElement('div');
                    guidance.className = 'status-item status-warning';
                    guidance.innerHTML = `
                        <span>No data loaded</span>
                        <small>Place JSON files or all-tasks.json in site root</small>
                    `;
                    statusEl.appendChild(guidance);
                }
            }
            
            handleKeyboard(e) {
                const focused = document.activeElement;
                if (!focused || focused.tagName === 'INPUT' || focused.tagName === 'TEXTAREA') return;
                
                if (focused.classList.contains('task-item')) {
                    const taskId = focused.dataset.taskId;
                    
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.toggleTaskSelection(taskId);
                    } else if (e.key === 'ArrowUp' && e.altKey) {
                        e.preventDefault();
                        this.moveItemUp(taskId, 'task');
                    } else if (e.key === 'ArrowDown' && e.altKey) {
                        e.preventDefault();
                        this.moveItemDown(taskId, 'task');
                    }
                }
            }
            
            moveItemUp(id, type) {
                const visibleOrder = this.getVisibleItemOrder();
                const index = visibleOrder.findIndex(item => item.id === id && item.type === type);
                if (index > 0) {
                    this.swapItemsInGlobalOrder(visibleOrder[index], visibleOrder[index - 1]);
                    this.saveState();
                    this.renderTasks();
                }
            }
            
            moveItemDown(id, type) {
                const visibleOrder = this.getVisibleItemOrder();
                const index = visibleOrder.findIndex(item => item.id === id && item.type === type);
                if (index >= 0 && index < visibleOrder.length - 1) {
                    this.swapItemsInGlobalOrder(visibleOrder[index], visibleOrder[index + 1]);
                    this.saveState();
                    this.renderTasks();
                }
            }
            
            getVisibleItemOrder() {
                const filteredTasks = this.getFilteredTasks();
                const filteredTaskIds = new Set(filteredTasks.map(t => t.id));
                
                return this.state.itemOrder.filter(item => {
                    if (item.type === 'task') {
                        return filteredTaskIds.has(item.id);
                    } else if (item.type === 'note') {
                        const note = this.notes.find(n => n.id === item.id);
                        return note && note.location === 'list';
                    }
                    return false;
                });
            }
            
            swapItemsInGlobalOrder(item1, item2) {
                const index1 = this.state.itemOrder.findIndex(item => 
                    item.type === item1.type && item.id === item1.id
                );
                const index2 = this.state.itemOrder.findIndex(item => 
                    item.type === item2.type && item.id === item2.id
                );
                
                if (index1 !== -1 && index2 !== -1) {
                    [this.state.itemOrder[index1], this.state.itemOrder[index2]] = 
                    [this.state.itemOrder[index2], this.state.itemOrder[index1]];
                }
            }
            
            setupDragAndDrop() {
                const taskList = document.getElementById('taskList');
                const notesList = document.getElementById('notesList');
                
                // Setup drag handlers for task list
                this.setupTaskListDrag(taskList);
                
                // Setup drag handlers for notes sidebar
                this.setupNotesListDrag(notesList, taskList);
            }
            
            setupTaskListDrag(taskList) {
                taskList.addEventListener('dragstart', (e) => {
                    const item = e.target.closest('.task-item, .note-item');
                    if (!item) return;
                    
                    this.dragState = {
                        type: item.classList.contains('task-item') ? 'task' : 'note',
                        id: item.dataset.taskId || item.dataset.noteId,
                        element: item,
                        sourceList: 'main'
                    };
                    
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.outerHTML);
                });
                
                taskList.addEventListener('dragover', (e) => {
                    if (!this.dragState) return;
                    e.preventDefault();
                    
                    this.removeDragPlaceholder();
                    const afterElement = this.getDragAfterElement(taskList, e.clientY);
                    
                    this.dragPlaceholder = document.createElement('div');
                    this.dragPlaceholder.className = 'drag-placeholder';
                    
                    if (afterElement == null) {
                        taskList.appendChild(this.dragPlaceholder);
                    } else {
                        taskList.insertBefore(this.dragPlaceholder, afterElement);
                    }
                });
                
                taskList.addEventListener('drop', (e) => {
                    if (!this.dragState || !this.dragPlaceholder) return;
                    e.preventDefault();
                    
                    const placeholderIndex = this.getPlaceholderIndex(taskList);
                    this.handleDrop(placeholderIndex);
                });
                
                taskList.addEventListener('dragend', () => {
                    this.cleanupDrag();
                });
                
                taskList.addEventListener('dragleave', (e) => {
                    if (!taskList.contains(e.relatedTarget)) {
                        this.removeDragPlaceholder();
                    }
                });
            }
            
            setupNotesListDrag(notesList, taskList) {
                notesList.addEventListener('dragstart', (e) => {
                    const noteItem = e.target.closest('.note-item');
                    if (!noteItem) return;
                    
                    this.dragState = {
                        type: 'note',
                        id: noteItem.dataset.noteId,
                        element: noteItem,
                        sourceList: 'sidebar'
                    };
                    
                    noteItem.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', noteItem.outerHTML);
                });
                
                // Allow dropping notes from sidebar to main list
                taskList.addEventListener('dragenter', (e) => {
                    if (this.dragState && this.dragState.sourceList === 'sidebar') {
                        e.preventDefault();
                        taskList.classList.add('drag-over');
                    }
                });
                
                taskList.addEventListener('dragleave', (e) => {
                    if (this.dragState && this.dragState.sourceList === 'sidebar' && 
                        !taskList.contains(e.relatedTarget)) {
                        taskList.classList.remove('drag-over');
                    }
                });
                
                taskList.addEventListener('drop', (e) => {
                    if (this.dragState && this.dragState.sourceList === 'sidebar') {
                        e.preventDefault();
                        taskList.classList.remove('drag-over');
                        
                        // Move note from sidebar to main list
                        const note = this.notes.find(n => n.id === this.dragState.id);
                        if (note) {
                            note.location = 'list';
                            // Add to end of current visible items
                            const visibleOrder = this.getVisibleItemOrder();
                            const insertIndex = this.state.itemOrder.findIndex(item => 
                                item.type === visibleOrder[visibleOrder.length - 1]?.type && 
                                item.id === visibleOrder[visibleOrder.length - 1]?.id
                            ) + 1;
                            
                            this.state.itemOrder.splice(insertIndex, 0, { type: 'note', id: this.dragState.id });
                            this.saveState();
                            this.render();
                        }
                    }
                });
            }
            
            getPlaceholderIndex(container) {
                const children = Array.from(container.children);
                return children.indexOf(this.dragPlaceholder);
            }
            
            handleDrop(placeholderIndex) {
                if (this.dragState.sourceList === 'main') {
                    // Reordering within main list
                    const visibleOrder = this.getVisibleItemOrder();
                    const currentVisibleIndex = visibleOrder.findIndex(item => 
                        item.type === this.dragState.type && item.id === this.dragState.id
                    );
                    
                    if (currentVisibleIndex !== -1) {
                        // Remove from current position in visible order
                        const [movedItem] = visibleOrder.splice(currentVisibleIndex, 1);
                        
                        // Insert at new position
                        const newIndex = currentVisibleIndex < placeholderIndex ? placeholderIndex - 1 : placeholderIndex;
                        visibleOrder.splice(newIndex, 0, movedItem);
                        
                        // Update global order based on new visible order
                        this.updateGlobalOrderFromVisible(visibleOrder);
                    }
                }
                
                this.saveState();
                this.renderTasks();
                this.cleanupDrag();
            }
            
            updateGlobalOrderFromVisible(visibleOrder) {
                // Create a map of current positions for visible items
                const visiblePositions = new Map();
                visibleOrder.forEach((item, index) => {
                    visiblePositions.set(`${item.type}::${item.id}`, index);
                });
                
                // Sort global order to match visible order for visible items
                const filteredTasks = this.getFilteredTasks();
                const filteredTaskIds = new Set(filteredTasks.map(t => t.id));
                
                this.state.itemOrder.sort((a, b) => {
                    const aVisible = (a.type === 'task' && filteredTaskIds.has(a.id)) || 
                                   (a.type === 'note' && this.notes.find(n => n.id === a.id)?.location === 'list');
                    const bVisible = (b.type === 'task' && filteredTaskIds.has(b.id)) || 
                                   (b.type === 'note' && this.notes.find(n => n.id === b.id)?.location === 'list');
                    
                    if (aVisible && bVisible) {
                        const aPos = visiblePositions.get(`${a.type}::${a.id}`) ?? Infinity;
                        const bPos = visiblePositions.get(`${b.type}::${b.id}`) ?? Infinity;
                        return aPos - bPos;
                    } else if (aVisible) {
                        return -1;
                    } else if (bVisible) {
                        return 1;
                    }
                    return 0;
                });
            }
            
            cleanupDrag() {
                if (this.dragState?.element) {
                    this.dragState.element.classList.remove('dragging');
                }
                this.dragState = null;
                this.removeDragPlaceholder();
                document.getElementById('taskList').classList.remove('drag-over');
            }
            
            removeDragPlaceholder() {
                if (this.dragPlaceholder && this.dragPlaceholder.parentNode) {
                    this.dragPlaceholder.parentNode.removeChild(this.dragPlaceholder);
                }
                this.dragPlaceholder = null;
            }
            
            getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging), .note-item:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
            
            getFilteredTasks() {
                let filteredTasks = this.tasks;
                
                // Filter by active category
                if (this.state.activeCategory !== 'all') {
                    filteredTasks = filteredTasks.filter(task => task.category === this.state.activeCategory);
                }
                
                // Filter by collapsed categories (only in 'all' view)
                if (this.state.activeCategory === 'all') {
                    filteredTasks = filteredTasks.filter(task => 
                        !this.state.collapsedCategories.has(task.category)
                    );
                }
                
                return filteredTasks;
            }
            
            render() {
                this.renderTasks();
                this.renderCategoryControls();
                this.renderNotes();
                this.updatePointsDisplay();
                this.updatePerformanceInfo();
                
                // Setup drag and drop after rendering
                requestAnimationFrame(() => this.setupDragAndDrop());
            }
            
            renderTasks() {
                const taskList = document.getElementById('taskList');
                
                // Use DocumentFragment for better performance
                const fragment = document.createDocumentFragment();
                
                const filteredTasks = this.getFilteredTasks();
                const filteredTaskIds = new Set(filteredTasks.map(t => t.id));
                
                // Create ordered items list (only for filtered tasks)
                const orderedItems = [];
                
                this.state.itemOrder.forEach(orderItem => {
                    if (orderItem.type === 'task' && filteredTaskIds.has(orderItem.id)) {
                        const task = filteredTasks.find(t => t.id === orderItem.id);
                        if (task) orderedItems.push({ type: 'task', data: task });
                    } else if (orderItem.type === 'note') {
                        const note = this.notes.find(n => n.id === orderItem.id && n.location === 'list');
                        if (note) orderedItems.push({ type: 'note', data: note });
                    }
                });
                
                // Render items
                orderedItems.forEach(item => {
                    if (item.type === 'task') {
                        fragment.appendChild(this.createTaskElement(item.data));
                    } else {
                        fragment.appendChild(this.createNoteElement(item.data, true));
                    }
                });
                
                // Replace all content at once
                taskList.innerHTML = '';
                taskList.appendChild(fragment);
            }
            
            updatePerformanceInfo() {
                const visibleTasks = this.getFilteredTasks().length;
                const totalTasks = this.tasks.length;
                
                document.getElementById('visibleCount').textContent = visibleTasks;
                document.getElementById('totalCount').textContent = totalTasks;
            }
            
            createTaskElement(task) {
                const li = document.createElement('li');
                li.className = 'task-item';
                li.dataset.taskId = task.id;
                li.tabIndex = 0;
                li.draggable = true;
                li.setAttribute('role', 'listitem');
                li.setAttribute('aria-pressed', this.state.selectedTasks.has(task.id));
                
                if (this.state.selectedTasks.has(task.id)) {
                    li.classList.add('selected');
                }
                if (this.state.minimizedTasks.has(task.id)) {
                    li.classList.add('minimized');
                }
                
                const iconHtml = task.area ? 
                    `<img src="${task.area}" alt="" onerror="this.style.display='none'" loading="lazy">` : 
                    '?';
                
                li.innerHTML = `
                    <div class="task-header">
                        <div class="task-icon">${iconHtml}</div>
                        <div class="task-title">${this.escapeHtml(task.task)}</div>
                        <div class="task-controls">
                            <button class="btn minimize-btn" aria-label="Toggle minimize">
                                ${this.state.minimizedTasks.has(task.id) ? 'Expand' : 'Minimize'}
                            </button>
                        </div>
                    </div>
                    <div class="task-details">
                        ${task.information ? this.escapeHtml(task.information) : ''}
                    </div>
                    <div class="task-requirements">
                        ${task.requirements.text ? `<span>${this.escapeHtml(task.requirements.text)}</span>` : ''}
                        ${task.requirements.img ? 
                            `<img class="requirement-img" src="${task.requirements.img}" alt="" onerror="this.style.display='none'" loading="lazy">` : 
                            ''}
                    </div>
                    <div class="task-meta">
                        <div class="task-category">${task.category}</div>
                        <div class="task-points">${task.points}</div>
                    </div>
                `;
                
                li.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('btn')) {
                        this.toggleTaskSelection(task.id);
                    }
                });
                
                li.querySelector('.minimize-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleTaskMinimized(task.id);
                });
                
                return li;
            }
            
            createNoteElement(note, inMainList = false) {
                const div = document.createElement('div');
                div.className = `note-item ${inMainList ? 'in-main-list' : ''}`;
                div.dataset.noteId = note.id;
                div.draggable = true;
                div.setAttribute('role', 'listitem');
                
                div.innerHTML = `
                    <div class="note-header">
                        <div class="note-title">${this.escapeHtml(note.title)}</div>
                        <div>
                            <button class="btn" onclick="taskManager.toggleNoteEdit('${note.id}')">
                                ${note.editing ? 'Save' : 'Edit'}
                            </button>
                            <button class="btn" onclick="taskManager.deleteNote('${note.id}')">Delete</button>
                        </div>
                    </div>
                    <div class="note-content">
                        ${note.editing ? 
                            `<textarea class="note-edit" onblur="taskManager.updateNoteBody('${note.id}', this.value)">${this.escapeHtml(note.body)}</textarea>` :
                            `<div class="note-body">${this.escapeHtml(note.body)}</div>`}
                    </div>
                `;
                
                return div;
            }
            
            renderCategoryControls() {
                const controls = document.getElementById('categoryControls');
                controls.innerHTML = '';
                
                this.categories.forEach(category => {
                    const count = this.tasks.filter(t => t.category === category).length;
                    if (count === 0) return;
                    
                    const button = document.createElement('button');
                    button.className = 'btn category-btn';
                    button.innerHTML = `
                        <span>${category} (${count})</span>
                        <span>${this.state.collapsedCategories.has(category) ? 'Show' : 'Hide'}</span>
                    `;
                    
                    button.addEventListener('click', () => {
                        this.toggleCategoryCollapsed(category);
                    });
                    
                    controls.appendChild(button);
                });
            }
            
            renderNotes() {
                const notesList = document.getElementById('notesList');
                notesList.innerHTML = '';
                
                const sidebarNotes = this.notes.filter(note => note.location === 'sidebar');
                sidebarNotes.forEach(note => {
                    notesList.appendChild(this.createNoteElement(note));
                });
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            exportState() {
                return JSON.stringify({
                    ...this.state,
                    selectedTasks: Array.from(this.state.selectedTasks),
                    minimizedTasks: Array.from(this.state.minimizedTasks),
                    collapsedCategories: Array.from(this.state.collapsedCategories),
                    notes: this.notes,
                    version: 'v2'
                }, null, 2);
            }
            
            importState(jsonString) {
                try {
                    const imported = JSON.parse(jsonString);
                    
                    this.state = {
                        selectedTasks: new Set(imported.selectedTasks || []),
                        minimizedTasks: new Set(imported.minimizedTasks || []),
                        collapsedCategories: new Set(imported.collapsedCategories || []),
                        itemOrder: imported.itemOrder || [],
                        totalPoints: imported.totalPoints || 0,
                        activeCategory: imported.activeCategory || 'all'
                    };
                    
                    this.notes = imported.notes || [];
                    this.noteIdCounter = Math.max(0, ...this.notes.map(n => parseInt(n.id.split('::')[1]) || 0)) + 1;
                    
                    this.saveState();
                    this.render();
                    
                    return true;
                } catch (error) {
                    console.error('Import failed:', error);
                    return false;
                }
            }
        }
        
        // Initialize the app
        let taskManager;
        document.addEventListener('DOMContentLoaded', () => {
            taskManager = new TaskManager();
        });
    </script>
</body>
</html>
